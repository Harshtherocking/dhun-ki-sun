# -*- coding: utf-8 -*-
"""Music.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YdX9c02UXHnr84judnR0XMtoW1XdE0md
"""

import librosa
import librosa.display
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import cwt, morlet
import pywt
import os
import time

# Specify the path to the downloaded file
file_path = '/content/0_084.mp3'  # Replace with the actual file path

try:
    # Check if the file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    # Load the audio file with librosa
    amp, sr = librosa.load(file_path, sr=22050)
    print(f"Audio Shape: {amp.shape}, Sample Rate: {sr}")

except FileNotFoundError as e:
    print(e)
except Exception as e:
    print(f"An error occurred: {e}")
except Exception as e:
    print(f"Error loading the audio file: {e}")
except librosa.util.exceptions.ParameterError as param_error:
    print(f"Parameter error: {param_error}")

#Spectral features
    spectral_centroid = librosa.feature.spectral_centroid(y=amp, sr=sr)
    spectral_bandwidth = librosa.feature.spectral_bandwidth(y=amp, sr=sr)
    stacked_array = np.hstack(spectral_centroid)

    spectral_centroid1 = librosa.feature.spectral_centroid(y=amp, sr=sr)
    spectral_bandwidth1 = librosa.feature.spectral_bandwidth(y=amp, sr=sr)
    stacked_array1 = np.hstack(spectral_centroid1)

    # Save the stacked array as a CSV file
    try:
        np.savetxt("output.csv", stacked_array.T, delimiter=",", fmt="%f")
        print("File saved successfully!")
    except Exception as e:
        print(f"Error: {e}")


    print("Spectral Centroid:", spectral_centroid)
    print("Spectral Bandwidth:", spectral_bandwidth)

spectra= librosa.feature.zero_crossing_rate(y=amp)
    librosa.display.specshow(spectra,x_axis="time")
    # Waveform visualization
    plt.figure(figsize=(15, 5))
    librosa.display.waveshow(amp, sr=sr)
    plt.title('Waveform')
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude')

# # Short-Time Fourier Transform and Spectrogram
    D = librosa.stft(amp)
    S_db = librosa.amplitude_to_db(abs(D), ref=np.max )

    plt.figure(figsize=(12, 4))
    librosa.display.specshow(np.abs(S_db), sr=sr, x_axis='time', y_axis='hz', cmap='plasma')
    plt.colorbar(format='%+2.0f dB')
    plt.title('Spectrogram')

    chroma = librosa.feature.chroma_stft(y=amp, sr=sr)
    print(librosa.display.specshow(chroma, x_axis="time"))
    plt.figure(figsize=(12, 4))
    librosa.display.specshow(chroma, x_axis="time", cmap="magma")
    plt.colorbar()
    plt.title("Chroma Feature")
    plt.show()
    print("Spectrogram Shape (Frequency bins, Time frames):", D.shape)

#Normalized spectogram values
y, sr = librosa.load(file_path, sr=None, mono=True)

# Compute Spectrogram
D = np.abs(librosa.stft(y))

# Normalize Spectrogram (0 to 1)
D_norm = (D - np.min(D)) / (np.max(D) - np.min(D))

# Display Normalized Spectrogram
plt.figure(figsize=(12, 4))
librosa.display.specshow(D_norm, sr=sr, x_axis='time', y_axis='log', cmap='viridis')
plt.colorbar(label='Normalized Magnitude')
plt.title('Normalized Spectrogram')
plt.show()

print("Spectrogram shape:", D_norm.shape)

# MFCCs
    mfccs = librosa.feature.mfcc(y=amp, sr=sr, n_mfcc=13)
    print(f"MFCCs shape: {mfccs.shape}")

    plt.figure(figsize=(12, 4))
    librosa.display.specshow(mfccs, sr=sr, x_axis='time', cmap='magma')
    plt.colorbar()
    plt.title('MFCCs')
    plt.show()

#Normalized spectogram values\
y, sr = librosa.load(file_path, sr=None, mono=True)

# Compute MFCC (13 coefficients by default)
mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)

# Normalize MFCC (0 to 1)
mfccs_norm = (mfccs - np.min(mfccs)) / (np.max(mfccs) - np.min(mfccs))

# Display Normalized MFCC
plt.figure(figsize=(12, 4))
librosa.display.specshow(mfccs_norm, sr=sr, x_axis='time', cmap='magma')
plt.colorbar(label='Normalized Coefficients')
plt.title('Normalized MFCC')
plt.show()

print("MFCC shape:", mfccs_norm.shape)

frames = range(len(spectral_centroid))
t = librosa.frames_to_time(frames, sr=sr)
spectral_centroid = librosa.feature.spectral_centroid(y=amp, sr=sr)
spectral_bandwidth = librosa.feature.spectral_bandwidth(y=amp, sr=sr)
centroid = np.hstack(spectral_centroid)
bandwidth = np.hstack(spectral_bandwidth)
spectra= librosa.feature.zero_crossing_rate(y=amp)
print(spectra)
# Save the stacked array as a CSV file
try:
        np.savetxt("spectral_centroid_midi.csv", centroid.T, delimiter=",", fmt="%f")
        np.savetxt("spectral_bandwidth_midi.csv", bandwidth.T, delimiter=",", fmt="%f")

        print("File saved successfully!")
except Exception as e:
        print(f"Error: {e}")

frames = range(spectral_centroid.shape[1])  # Get the number of frames
t = librosa.frames_to_time(frames, sr=sr)  # Convert frame indices to time
plt.figure(figsize=(10, 6))
librosa.display.waveshow(amp, sr=sr, alpha=0.6, label="Waveform")
plt.plot(t, spectral_centroid.T / np.max(spectral_centroid), marker='x', color='r', label='Spectral Centroid')
#plt.plot(t, spectral_bandwidth.T / np.max(spectral_bandwidth), marker='o', color='b', label='Spectral Bandwidth')
plt.xlabel("Time (s)")
plt.ylabel("Normalized Value")
plt.legend()
plt.title("Waveform with Spectral Features")
plt.show()

plt.figure(figsize=(10, 6))
librosa.display.waveshow(amp, sr=sr, alpha=0.6, label="Waveform")
plt.plot(t, spectral_bandwidth.T / np.max(spectral_bandwidth), marker='o', color='b', label='Spectral Bandwidth')
plt.xlabel("Time (s)")
plt.ylabel("Normalized Value")
plt.legend()
plt.title("Waveform with Spectral Features")
plt.show()

y, sr = librosa.load(file_path, sr=None)

# Generate a spectrogram
D = np.abs(librosa.stft(y))

# Use the mean frequency content across time
spectrogram = np.mean(D, axis=1)

# Define wavelet scales (adjust for better resolution)
widths = np.arange(1, 128)

# Apply Continuous Wavelet Transform (CWT) using Morlet wavelet
cwt_result = cwt(spectrogram, morlet, widths)

# Visualize the Scalogram
plt.figure(figsize=(12, 8))
plt.imshow(np.abs(cwt_result), extent=[0, len(y) / sr, 1, 128], cmap='viridis', aspect='auto')
plt.colorbar(label="Magnitude")
plt.title("Scalogram of the Audio")
plt.xlabel("Time (s)")
plt.ylabel("Scale")
plt.show()

y, sr = librosa.load(file_path, sr=None, mono=True)

# Define wavelet scales and the wavelet type (using 'cmor' for continuous Morlet wavelet)
widths = np.arange(1, 128)  # Number of scales
wavelet = 'cmor1.5-1.0'     # Complex Morlet wavelet

# Compute the scalogram using PyWavelets
coeffs, _ = pywt.cwt(y, widths, wavelet, sampling_period=1/sr)

# Get the magnitude of the coefficients
scalogram = np.abs(coeffs)

# Normalize the scalogram (0 to 1)
scalogram_norm = (scalogram - np.min(scalogram)) / (np.max(scalogram) - np.min(scalogram))

# Display the normalized scalogram
plt.figure(figsize=(12, 8))
plt.imshow(scalogram_norm, extent=[0, len(y) / sr, 1, 128], cmap='plasma', aspect='auto')
plt.colorbar(label="Normalized Magnitude")
plt.title("Normalized Scalogram (Mono Audio)")
plt.xlabel("Time (s)")
plt.ylabel("Scale")
plt.show()

# Print the shape of the scalogram
print("Scalogram shape (Scales, Time frames):", scalogram_norm.shape)